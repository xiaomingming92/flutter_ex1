# 登录认证流程

## 1. 冷启动流程

```
main.dart: runApp(App())
    ↓
App.dart: initialRoute = '/splash'
    ↓
显示 SplashPage
    ↓
SplashIntentController.onInit()
    ↓
_authCtl = AuthIntentController.getInstance()  // 单例模式获取控制器实例
    ↓
_decideSplashMode() (异步)
    ├─ 读取 userInfo
    ├─ 判断是否首次登录
    ├─ 判断是否有 VIP 权限
    └─ 决定显示模式: static 或 ad
    ↓
AuthIntentController.onInit()
    ├─ 仅dev环境: _detectHotReload() 检测热重载
    ├─ _checkLoginStatus() (异步)
    │   ├─ 读取 accessToken、refreshToken、refreshExpiresAt
    │   ├─ 读取 userInfo
    │   ├─ 验证 token 是否过期
    │   ├─ 更新 isLoggedIn.value
    │   └─ 设置 isColdStart.value = false
    ├─ _setupLifeHookListener() 监听应用生命周期
    └─ _watchLoggedIn() 监听登录状态变化
    ↓
根据显示模式执行:
    ├─ 静态模式: _waitForAuthCheck()
    │   ├─ 等待 AuthIntentController.isColdStart.value = false
    │   └─ _navigateToTarget()
    │       ├─ isLoggedIn = true → Get.offAllNamed('/home')
    │       └─ isLoggedIn = false → Get.offAllNamed('/login')
    │
    └─ 广告模式: _startAdCountdown()
        ├─ 开始 5 秒倒计时
        ├─ 用户可手动跳过 (skipAd)
        └─ 倒计时结束或跳过 → _navigateToTarget()
            ├─ isLoggedIn = true → Get.offAllNamed('/home')
            └─ isLoggedIn = false → Get.offAllNamed('/login')
```

## 2. 热启动流程（从后台恢复）

```
用户从后台回到前台
    ↓
AppLifecycleState.resumed 触发
    ↓
AuthIntentController._handleStateChange()
    ↓
_checkLoginStatus() (异步)
    ├─ 读取 accessToken、refreshToken、refreshExpiresAt
    ├─ 验证 token 是否过期
    └─ 更新 isLoggedIn.value
    ↓
_watchLoggedIn() 触发
    ├─ 检查当前路由是否在豁免列表 (/login, /register, /forgot_password, /splash)
    ├─ isLoggedIn = true → 不跳转，保持当前页面栈
    └─ isLoggedIn = false → Get.offAllNamed('/login')
```

## 3. 热重载处理流程 (仅dev环境)

```
dev环境下触发热重载
    ↓
AuthIntentController.onInit() 重新执行
    ↓
_detectHotReload() 检测到控制器已注册
    ↓
设置 _shouldPreventNavigation = true
    ↓
3秒内禁止导航操作
    ↓
3秒后设置 _shouldPreventNavigation = false
    ↓
恢复正常导航功能
```

## 4. 登录操作流程

```
用户在 LoginPage 输入账号密码
    ↓
AuthIntentController.getInstance().handleLoginIntent(username, password)
    ↓
调用 AuthApi.login(username, password)
    ↓
获取 LoginRes 数据
    ├─ TokenManager.setTokens(loginData) → 存储 token
    ├─ UserManager.setUserInfoFromLogin(loginData) → 存储 userInfo
    └─ isLoggedIn.value = true
    ↓
Get.offAllNamed('/home')
```

## 5. 登出操作流程

```
用户点击登出按钮
    ↓
AuthIntentController.getInstance().handleLogoutIntent()
    ↓
TokenManager.clear() → 清除 token
    ↓
UserManager.clear() → 清除 userInfo
    ↓
isLoggedIn.value = false
    ↓
Get.offAllNamed('/login')
```

## 6. Token 过期处理流程

### 场景1：冷启动时 token 过期
```
_checkLoginStatus() 检测到 token 过期
    ↓
isLoggedIn.value = false
    ↓
isColdStart.value = false
    ↓
SplashIntentController 检测到 isColdStart.value = false
    ↓
_navigateToTarget() → Get.offAllNamed('/login')
```

### 场景2：热启动时 token 过期
```
AppLifecycleState.resumed 触发
    ↓
_checkLoginStatus() 检测到 token 过期
    ↓
isLoggedIn.value = false
    ↓
_watchLoggedIn() 触发
    ↓
Get.offAllNamed('/login')
```

### 场景3：API 请求时 token 过期
```
发起 API 请求
    ↓
服务器返回 401 或 token 过期错误
    ↓
TokenManager.refreshToken() 尝试刷新
    ├─ 成功 → 重试原请求
    └─ 失败 → isLoggedIn.value = false → 跳转 /login
```

## 7. AuthMiddleware 拦截流程

```
用户尝试访问需要认证的路由（/home, /feed, /profile 等）
    ↓
AuthMiddleware.redirect(route)
    ↓
检查 AuthIntentController.getInstance().getLoginStatus()
    ├─ has → 允许访问: return null
    └─ has not → 重定向到login: return RouteSettings(name: Routes.login);
```

## 8. UserInfo 缓存恢复流程

```
token 有效但 userInfo 缓存为空
    ↓
_checkLoginStatus() 检测到 !UserManager.hasUserInfo()
    ↓
调用 UserApi.getUserInfoMap()
    ├─ 成功 → UserManager.setUserInfo(userInfo)
    └─ 失败 → isLoggedIn.value = false → 跳转 /login
```

## 9. 启动页显示逻辑

### 静态启动页
```
条件满足其一:
    ├─ 非首次登录用户
    ├─ 无 VIP 权限
    └─ 没有 vip.splash.showAd 权限
    ↓
显示静态 Logo 页
    ↓
等待 AuthIntentController 完成检查
    ↓
立即跳转到目标页面
```

### 广告启动页
```
条件满足其一:
    ├─ 首次登录用户
    └─ 有 vip.splash.showAd 权限
    ↓
显示广告页
    ↓
开始 5 秒倒计时
    ├─ 用户可点击"跳过"按钮
    └─ 倒计时自动递减
    ↓
倒计时结束或用户跳过
    ↓
跳转到目标页面
```

## 核心决策逻辑

### SplashIntentController 核心职责

1. **启动页模式决策**：根据用户信息决定显示静态页还是广告页
2. **跳转时机控制**：控制何时允许跳转到目标页面
3. **广告倒计时管理**：管理广告显示时长和用户跳过操作
4. **路由决策**：根据登录状态决定跳转到首页还是登录页
5. **单例控制器获取**：通过 AuthIntentController.getInstance() 获取全局唯一控制器实例

### AuthIntentController 核心职责

1. **状态管理**：维护 `isLoggedIn` 和 `isColdStart` 响应式变量
2. **登录状态检查**：检查 token 和 userInfo 的有效性
3. **生命周期监听**：处理热启动时的 token 验证
4. **热重载检测**：仅在 dev 环境检测热重载并暂时禁止导航
5. **精细化导航控制**：基于当前路由、登录状态和热重载状态控制跳转
6. **数据缓存**：管理 token 和 userInfo 的存储
7. **单例模式实现**：通过 getInstance() 方法确保全局唯一实例

### 路由决策规则

| 场景 | Token | UserInfo | 启动页模式 | 热重载状态 | 操作 |
|------|-------|----------|-----------|-----------|------|
| 冷启动 | 有效 | 存在 | static/ad | - | 等待检查后跳转 |
| 冷启动 | 有效 | 不存在 | static/ad | - | 获取 userInfo，成功跳 /home，失败跳 /login |
| 冷启动 | 无效 | - | static/ad | - | 跳转 /login |
| 热启动 | 有效 | - | - | - | 保持当前页面 |
| 热启动 | 无效 | - | - | - | 跳转 /login |
| 热重载 | - | - | - | 进行中 | 禁止导航 3 秒 |

## 技术实现要点

### 1. 单例模式实现

```dart
static AuthIntentController getInstance() {
  if (Get.isRegistered<AuthIntentController>()) {
    return Get.find<AuthIntentController>();
  } else {
    return Get.put(AuthIntentController());
  }
}

// 使用方式
final authCtl = AuthIntentController.getInstance();
```

### 2. 热重载检测（仅dev环境）

```dart
@override
void onInit() {
  super.onInit();
  if(Env.current.envName == 'dev') {
    _detectHotReload();
  }
  // 其他初始化逻辑
}

void _detectHotReload() {
  if (Get.isRegistered<AuthIntentController>()) {
    _shouldPreventNavigation = true;
    Future.delayed(const Duration(seconds: 3), () {
      _shouldPreventNavigation = false;
    });
  }
}
```

### 3. 精细化导航控制

```dart
void _watchLoggedIn() {
  ever(isLoggedIn, (value) {
    if (isColdStart.value) {
      // 冷启动：不跳转，由 SplashIntentController 控制跳转
      return;
    } else if (_shouldPreventNavigation) {
      // 热重载期间不执行跳转
      return;
    } else {
      if (!value) {
        // 获取当前路由
        final currentRoute = Get.currentRoute;
        
        // 检查当前是否已经在登录页，避免重复跳转
        if (currentRoute == '/login') {
          return;
        }
        
        // 检查是否在豁免页面（不需要登录的页面）
        final exemptRoutes = ['/register', '/forgot_password', '/splash'];
        if (exemptRoutes.contains(currentRoute)) {
          return;
        }
        
        // 执行跳转
        Get.offAllNamed('/login');
      }
    }
  });
}
```

### 4. 冷热启动区分

```dart
final RxBool isColdStart = true.obs;  // 响应式变量，支持 GetX 监听

@override
void onInit() {
  super.onInit();
  _checkLoginStatus();
}

Future<void> _checkLoginStatus() async {
  // 登录状态检查逻辑
  
  // 检查完成后标记为热启动
  isColdStart.value = false;
}
```

### 5. 应用生命周期监听

```dart
void _setupLifeHookListener() {
  _lifeHookListener = AppLifecycleListener(
    onStateChange: _handleStateChange,
  );
}

void _handleStateChange(AppLifecycleState state) {
  if (state == AppLifecycleState.resumed) {
    // 应用恢复前台时重新检查登录状态
    _checkLoginStatus();
  }
}
```

### 6. SplashIntentController 等待 AuthIntentController

```dart
void _waitForAuthCheck() {
  final authCtl = AuthIntentController.getInstance();
  ever(authCtl.isColdStart, (value) {
    if (!value) {
      // 检查完成，允许跳转
      canNavigate.value = true;
      _navigateToTarget();
    }
  });
}
```

### 7. 广告倒计时实现（基于时间戳）

```dart
void _startAdCountdown() async {
  _adStartTime = DateTime.now();
  _adEndTime = _adStartTime?.add(Duration(seconds: _adDurationSeconds));

  while (_adEndTime?.isAfter(DateTime.now()) ?? false) {
    final remainingSeconds = _adEndTime!.difference(DateTime.now()).inSeconds;
    adCountdown.value = remainingSeconds;
    await Future.delayed(const Duration(milliseconds: 100));
  }
  
  _onAdFinished();
}
```

### 8. Token 验证逻辑

```dart
Future<void> _checkLoginStatus() async {
  final [accessToken, refreshToken, refreshExpiresAt] = await Future.wait([
    TokenManager.getAccessToken(),
    TokenManager.getRefreshToken(),
    TokenManager.getRefreshExpiresAt(),
  ]);
  
  if ([accessToken, refreshToken, refreshExpiresAt].any((e) => e == null)) {
    isLoggedIn.value = false;
    await UserManager.clear();
    isColdStart.value = false;
    return;
  }
  
  final isValid = (refreshExpiresAt as int) >= DateTime.now().millisecondsSinceEpoch;
  isLoggedIn.value = isValid;
  isColdStart.value = false;
  
  // 如果 token 有效，尝试恢复用户信息缓存
  if (isValid && !UserManager.hasUserInfo()) {
    try {
      final userInfo = await UserApi.getUserInfoMap();
      if (userInfo.isNotEmpty) {
        await UserManager.setUserInfo(userInfo);
      }
    } catch (e) {
      // 获取用户信息失败，不影响登录状态
    }
  }
}
```

### 9. 启动页模式决策

```dart
Future<SplashMode> _computeSplashMode() async {
  final userInfo = await UserManager.getUserInfoAsync();
  
  // 1. 检查是否首次登录
  if (userInfo == null || userInfo.isEmpty) {
    return SplashMode.ad;
  }
  
  final isNewUser = userInfo['isNewUser'] ?? false;
  if (isNewUser) {
    return SplashMode.ad;
  }
  
  // 2. 检查是否有 VIP 权限
  final permissions = userInfo['permissions'] as List<dynamic>?;
  if (permissions == null || permissions.isEmpty) {
    return SplashMode.static;
  }
  
  // 3. 检查是否有 vip.splash.showAd 权限
  final hasShowAdPermission = permissions.contains('vip.splash.showAd');
  
  return hasShowAdPermission ? SplashMode.ad : SplashMode.static;
}
```

## 存储结构

### TokenManager 存储键

- `accessToken`: 访问令牌
- `refreshToken`: 刷新令牌
- `refreshExpiresAt`: 刷新令牌过期时间戳

### UserManager 存储键

- `userInfo`: 用户详细信息 JSON 字符串
- `maskedPhone`: 脱敏手机号

## 相关文件

- `lib/intent_controller/splash_intent_controller.dart`: 启动页意图控制器
- `lib/intent_controller/auth_intent_controller.dart`: 认证意图控制器（核心）
- `lib/network/token_manager.dart`: Token 管理
- `lib/network/user_manager.dart`: 用户信息管理
- `lib/routes/routes.dart`: 路由配置
- `lib/main.dart`: 应用入口
- `lib/app/app.dart`: 应用配置
- `lib/widgets/firstScreenStatic.dart`: 静态启动页组件
- `lib/widgets/ad_widget.dart`: 广告页组件
- `lib/env/env.dart`: 环境配置管理